
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Manejo de usuarios con Promesas</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="Google Analytics ID"
                  id="ProgramacionWeb-codelab-011121"
                  title="Manejo de usuarios con Promesas"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Bienvenida" duration="5">
        <p>En este curso aprender√°s acerca de las promesas, qu√© son y c√≥mo se usan en JavaScript, adem√°s de c√≥mo resolver promesas de diferentes maneras.</p>
<h2 is-upgraded>Resultado esperado</h2>
<p class="image-container"><img alt="result" src="img\\ed8155e16863ced.gif"></p>
<h2 is-upgraded>¬øQu√© aprender√°s?</h2>
<ul>
<li>Introducci√≥n a procesos as√≠ncronos</li>
<li>Promesas</li>
<li>Manejo de promesas con <strong>then</strong>, <strong>catch</strong> y <strong>finally</strong></li>
<li>Manejo de promesas con <strong>try-catch</strong></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Configuraci√≥n del entorno" duration="10">
        <h2 is-upgraded>IDE</h2>
<p>El editor de texto a trabajar ser√° Visual Studio Code, si no tienes instalado dicho editor lo puedes descargar desde el siguiente <a href="https://code.visualstudio.com/" target="_blank">enlace</a>.</p>
<h2 is-upgraded>Clonar el repositorio base</h2>
<p>Asumimos que tienes instalado <a href="https://git-scm.com/" target="_blank">git</a>, clona el repositorio <a href="https://github.com/Programacion-Web-0221-UCA/L02-ASYNCWORK" target="_blank">base</a> de la siguiente manera en tu lugar de preferencia:</p>
<pre>git clone https://github.com/Programacion-Web-0221-UCA/L02-ASYNCWORK.git
</pre>
<p>Despu√©s de clonar el repositorio accedemos a √©l mediante el comando:</p>
<pre>cd L02-ASYNCWORK
</pre>
<h2 is-upgraded>Archivos</h2>
<p>En el repositorio encontrar√°s el archivo <strong>index.html</strong> junto a los estilos propuestos en el archivo <strong>styles.css</strong>.</p>
<aside class="warning"><p> NOTA: Aseg√∫rate tener instalado Live Server para poder servir la aplicaci√≥n localmente. </p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Modelo de JavaScript" duration="10">
        <h2 is-upgraded>Introducci√≥n</h2>
<p>Es importante conocer c√≥mo trabaja un lenguaje de programaci√≥n para lograr entender su comportamiento o c√≥mo realiza diferentes operaciones con la finalidad de prevenir errores a gran escala.</p>
<h2 is-upgraded>Objetivos</h2>
<ul>
<li>Conocimiento de operaciones bloqueantes y no bloqueantes</li>
<li>Conocimiento de operaciones s√≠ncronas y as√≠ncronas</li>
<li>Conocer c√≥mo funcionan las peticiones de red</li>
</ul>
<h2 is-upgraded>Bloqueante y No Bloqueante</h2>
<p>Los procesos bloqueantes hacen referencia a c√≥mo se ejecuta un c√≥digo en tiempo de compilaci√≥n y c√≥mo afecta esa fase de espera a nuestro programa.</p>
<p class="image-container"><img alt="Blocking-Non" title="Blocking and non-blocking" src="img\\fecd9e2a96576b81.PNG"></p>
<ul>
<li><strong>Bloqueante</strong> : Una llamada u operaci√≥n bloqueante no devuelve el control a nuestra aplicaci√≥n hasta que se ha completado.</li>
<li><strong>No bloqueante</strong> : Una llamada no bloqueante devuelve inmediatamente con independencia del resultado. En caso de que se haya completado, devolver√° los datos solicitados.</li>
</ul>
<aside class="warning"><p>   BLOQUEANTE: El control no es devuelto hasta que el proceso bloqueante termine. </p>
</aside>
<aside class="special"><p>   NO BLOQUEANTE: La llamada es devuelta independiente del resultado, por ende es necesario controlar si nuestra petici√≥n ha sido exitosa o no. </p>
</aside>
<h2 is-upgraded>Sincronismo y Asincronismo</h2>
<p>Es muy com√∫n emplear o encontrar relaci√≥n con procesos s√≠ncronos y as√≠ncronos con procesos bloqueantes y no bloqueantes, pero los procesos s√≠ncronos y as√≠ncronos se refieren a cuando tendr√° lugar una respuesta.</p>
<p class="image-container"><img alt="Syncronus-Asyncronus" title="Asyncronus" src="img\\b9f1397c890aeb0.PNG"></p>
<ul>
<li><strong>S√≠ncrono</strong> : Proceso que se ejecuta de forma secuencial.</li>
<li><strong>As√≠ncrono</strong> : Proceso en el cual se obtiene la respuesta y se notifica mediante mecanismos espec√≠ficos para que dicha informaci√≥n logre ser gestionada.</li>
</ul>
<aside class="warning"><p>   S√çNCRONO: Retorna cuando la ejecuci√≥n termina.  </p>
</aside>
<aside class="special"><p>   AS√çNCRONO: La finalizaci√≥n de la operaci√≥n es notificada al programa principal. </p>
</aside>
<h2 is-upgraded>Peticiones a la red</h2>
<p>JavaScript trabaja principalmente con navegadores, por lo cual un proceso bloqueante y s√≠ncrono no ayudar√≠a a procesar peticiones sobre la red de una manera fluida para los usuarios, por lo cual <strong>JavaScript utiliza un modelo as√≠ncrono y no bloqueante</strong> para las interfaces entrada y salida ya que estas aseguran la ejecuci√≥n de diferentes procesos de manera simult√°nea.</p>
<h3 is-upgraded>¬øPor qu√© es necesario este modelo?</h3>
<p>Al momento de solicitar datos desde diferentes redes de comunicaciones, es importante conocer que no es un proceso directo, es decir, intervienen servicios externos que retrasan dicha comunicaci√≥n</p>
<p class="image-container"><img alt="no-direct" title="no direct response" src="img\\6de6ad2132259d31.PNG"></p>
<h3 is-upgraded>Enviando una petici√≥n</h3>
<p>Al permitir un modelo as√≠ncrono y no bloqueante permite realizar peticiones a un servidor o lugar no remoto y estar seguros de obtener una respuesta en un periodo de tiempo.</p>
<p class="image-container"><img alt="send-request" title="Send request" src="img\\2fc891e566204990.PNG"></p>
<h3 is-upgraded>Recibiendo una respuesta</h3>
<p>Al servidor obtener nuestra petici√≥n, la procesar√° y nos enviar√° una respuesta.</p>
<p class="image-container"><img alt="get-response" title="Get response" src="img\\b8cda85dc422de77.PNG"></p>
<aside class="special"><p>   NOTA: Al ser un proceso as√≠ncrono, la respuesta que se obtiene no siempre ser√° la solicitada </p>
</aside>
<p>Ahora sabemos c√≥mo funcionan las comunicaciones con servidores y qu√© nos devuelven la informaci√≥n que solicitemos, pero <strong>¬øc√≥mo obtenemos dicha informaci√≥n?</strong></p>


      </google-codelab-step>
    
      <google-codelab-step label="Promesas" duration="0">
        <h2 is-upgraded>Introducci√≥n</h2>
<p>Al trabajar con un modelo <strong>bloqueante y as√≠ncrono</strong> es importante poseer una forma de asegurar que dichas respuestas sean recibidas por nuestro programa de una forma controlada y segura. JavaScript nos provee el manejo de procesos as√≠ncronos con la ayuda de <strong>Promesas</strong></p>
<h2 is-upgraded>Objetivos</h2>
<ul>
<li>Conocimiento de una Promesa</li>
<li>Uso de promesas</li>
<li>Introducci√≥n a fetch API</li>
</ul>
<h2 is-upgraded>¬øQu√© son?</h2>
<p>Las promesas son valores que pueden estar disponibles ahora, en el futuro o nunca. Se puede describir a una promesa como una especie de Karma.</p>
<aside class="special"><p>   Si tu haces algo, en consecuencia obtendras algo, ahora o en un futuro </p>
</aside>
<h2 is-upgraded>Estados de una promesa</h2>
<p>Una promesa recuerda el contexto en donde se ejecut√≥, es decir, sabe con precisi√≥n el punto donde se ha de resolver un valor o lanzar un error. Cuando una promesa entra en ejecuci√≥n pasa a tener ser resuelta con dos tipos de estados:</p>
<ul>
<li><strong>fulfilled</strong>: Estado que indica que la promesa se ha resuelto exitosamente.</li>
<li><strong>rejected</strong>: Estado que indica que la promesa ha sido rechazada o que algo malo sucedi√≥ en su ejecuci√≥n.</li>
</ul>
<aside class="warning"><p>   NOTA: Inicialmente las promesas tienen el estado <strong>pending</strong> que cambiar√° cuando se haya resuelto la promesa </p>
</aside>
<h2 is-upgraded>Sintaxis</h2>
<pre><code language="language-javascript" class="language-javascript">const promise = new Promise(function (resolve, reject) {
  //logic...
});
</code></pre>
<aside class="special"><p><strong>resolve</strong> y <strong>reject</strong> son funciones que se ejecutaran dependiendo del resultado de la promesa </p>
</aside>
<h2 is-upgraded>Ejemplo de promesa</h2>
<pre><code language="language-javascript" class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&#34;Successfully promise result&#34;);
  }, 250);
});

promise
  .then((response) =&gt; {
    console.log(response);
  })
  .catch((error) =&gt; {
    console.log(error);
  });
</code></pre>
<p>Cuando la promesa se resuelva, la respuesta pasa al <strong>.then</strong>. Ac√° debemos colocar la acci√≥n que se realizar√° cuando la promesa se resuelva exitosamente. Si la respuesta no se completa, <strong>.catch</strong> tomar√° dicho error e igualmente podemos realizar una acci√≥n con dicha respuesta.</p>
<aside class="special"><p><strong>setTimeout</strong> simula un proceso as√≠ncrono, ya que realiza la acci√≥n pasados 250 milisegundos. </p>
</aside>
<h2 is-upgraded>fetch API</h2>
<h3 is-upgraded>¬øQu√© es?</h3>
<p><strong>Fetch API</strong> es una interfaz simple para la b√∫squeda de recursos. Fetch nos facilita el trabajo para hacer solicitudes a servidores o lugares no remotos y manejar sus respuestas.</p>
<h2 is-upgraded>Ejemplo de fetch</h2>
<pre><code language="language-javascript" class="language-javascript">function logResult(result) {
  console.log(result);
}

function logError(error) {
  console.error(&#34;A problem has occurred&#34;);
}

function validateResponse(response) {
  if (!response.ok) {
    throw new Error(response.statusText);
  }

  return response;
}

function readResponseAsJSON(response) {
  return response.json();
}

fetch(&#34;example/example.json&#34;)
  .then(validateResponse)
  .then(readResponseAsJSON)
  .then(logResult)
  .catch(logError);
</code></pre>
<p>Resumiendo el bloque de c√≥digo:</p>
<p><strong>Paso 1</strong>: Se llama a fetch para obtener el recurso example.json. Fetch retorna una promesa que ser√° resuelta con un objeto. Si la respuesta pasa, entrar√° a <strong>validateResponse</strong>. </p>
<p><strong>Paso 2</strong>: <strong>validateResponse</strong> verifica que el <strong>status code</strong> se encuentre entre 200-299. Si no se encuentra, se lanzar√° un error que se recibir√° en el m√©todo <strong>catch</strong>. De lo contrario, pasar√° a <strong>readResponseAsJSON</strong>.</p>
<p><strong>Paso 3</strong>: Se transforma la respuesta a objeto tipo JSON. Este m√©todo retorna una promesa que se resuelve como JSON. Una vez se resuelva, pasar√° al m√©todo <strong>logResult</strong> (¬øqu√© pasara si la respuesta no se transforma a un objeto JSON?). </p>
<p><strong>Paso 4</strong>: Se muestra en consola la respuesta ya transformada.</p>

      </google-codelab-step>
    
      <google-codelab-step label="Parte 1 - Funciones as√≠ncronas" duration="0">
        <h2 is-upgraded>Introducci√≥n</h2>
<p>Las funciones as√≠ncronas son aquellas que no tienen un tiempo espec√≠fico de ejecuci√≥n, sino que dependen de muchos factores pero nos aseguran se resolver√°n en un futuro</p>
<h2 is-upgraded>Objetivos</h2>
<ul>
<li>Conocimiento de Async y Await</li>
<li>Uso de promesas</li>
<li>Obtenci√≥n y conversi√≥n de datos</li>
</ul>
<h2 is-upgraded>Obtener los usuarios</h2>
<p>De la carpeta <strong>data</strong> consultaremos el archivo <strong>human_500.json</strong> para obtener diferentes usuarios y sus caracter√≠sticas, de las cuales nos interesan</p>
<ol type="1">
<li>id</li>
<li>image</li>
<li>username</li>
<li>email</li>
<li>gender</li>
<li>fullname</li>
<li>country</li>
</ol>
<aside class="warning"><p>  NOTA: No siempre es necesario ocupar todos los campos brindados </p>
</aside>
<h2 is-upgraded>Async - Await</h2>
<p>En las nuevas versiones de <strong>JavaScript</strong> se incluyen dos nuevas palabras reservadas, <strong>Async</strong> y <strong>await</strong>. Ambas palabras son una variante al trabajo de procesos as√≠ncronos, tal como <strong>Promise</strong> y <strong>then</strong>. Estas surgen con el prop√≥sito de mostrar una secuencia de c√≥digo m√°s tradicional, es decir, un c√≥digo secuencial sin dejar de ser c√≥digo as√≠ncrono</p>
<h3 is-upgraded>Uso</h3>
<pre><code language="language-javascript" class="language-javascript">const fetchData = async () =&gt; {
  try {
    const response = await fetch(&#34;data/data.json&#34;);
    const data = await response.json();

    return data;
  } catch (error) {
    console.log(&#34;A problem has occurred&#34;);
  }
};
</code></pre>
<p>Resumiendo el bloque de c√≥digo mostrado</p>
<p><strong>Paso 1</strong>: Declaramos una funci√≥n flecha con la palabra <strong>async</strong>. Lo que indicar√° que esta funci√≥n ahora devolver√° expl√≠citamente una Promesa.</p>
<p><strong>Paso 2</strong>: Se enuncia un <strong>try-catch</strong> para el manejo de los errores. Esta parte es importante porque <strong>async-await</strong> nos devolver√° una respuesta, pero no provee un m√©todo propio para manejar errores de manera nativa.</p>
<p><strong>Paso 3</strong>: Realizamos una llamada con fetch a <strong>data/data.json</strong> con la palabra <strong>await</strong>. Esto indica que el programa no avanzar√° hasta que se complete esa llamada, esta es una de las principales diferencias al usar <strong>.then</strong>. Si la respuesta es exitosa, entonces avanzar√° a la siguiente l√≠nea de c√≥digo, de lo contrario entrar√° a nuestra sentencia <strong>catch</strong> con dicho error. </p>
<p><strong>Paso 4</strong>: De igual manera, usamos <strong>await</strong> para realizar la conversi√≥n de nuestra respuesta a un objeto.</p>
<p><strong>Paso 5</strong>: Retornamos la respuesta</p>

<aside class="special"><p>   NOTA: Como se puede observar, obtenemos un c√≥digo secuencial de una manera as√≠ncrona ya que con await esperamos directamente la respuesta de un proceso as√≠ncrono </p>
</aside>
<h3 is-upgraded>Comparaci√≥n con then</h3>
<pre><code language="language-javascript" class="language-javascript">const fetchData = fetch(&#34;data/data.json&#34;)
  .then((response) =&gt; response.json())
  .then((data) =&gt; data)
  .catch((error) =&gt; {
    console.log(&#34;A problem has occurred&#34;);
  });
</code></pre>
<aside class="warning"><p>   NOTA: async-await se puede mezclar con then, no son excluyentes el uno del otro </p>
</aside>
<h2 is-upgraded>Guardando los datos</h2>
<p>Para poder obtener los datos que se encuentran en el archivo indicado, utilizaremos <strong>async-await</strong>. Por lo cual, declaramos una funci√≥n llamada <strong>fetchData</strong> , la cual recibir√° la direcci√≥n del archivo donde se encuentran nuestros datos y una funci√≥n <strong>fetchUsers</strong> que tendr√° como objetivo obtener dichos usuarios para posteriormente renderizarlos</p>
<pre><code language="language-javascript" class="language-javascript">const fetchData = async (url) =&gt; {
  let data = undefined;

  try {
    const response = await fetch(url);

    if (response.ok) {
      data = await response.json();
    } else {
      console.warn(&#34;invalid request&#34;);
    }
  } catch (error) {
    console.error({ error });
    console.error(&#34;Error in fetch data&#34;);
  } finally {
    return data;
  }
};

const fetchUsers = async () =&gt; {
  users = (await fetchData(&#34;/data/human_1000.json&#34;)) ?? [];
};
</code></pre>
<p>Pasos a destacar del bloque de c√≥digo mostrado</p>
<p><strong>Paso 1</strong>: Verificar la respuesta con <strong>response.ok</strong>, el cual ser√° verdadero si se el <strong>status code</strong> se encuentra entre 200 y 299.</p>
<aside class="special"><p>   NOTA: finally se ejecuta sin importar si hubo un error o no </p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Parte 2 - Funciones de renderizaci√≥n" duration="0">
        <h2 is-upgraded>Introducci√≥n</h2>
<p>Las funciones de renderizaci√≥n nos ayudan a mostrar los cambios en pantalla a los usuarios.</p>
<h2 is-upgraded>Objetivos</h2>
<ul>
<li>Renderizar un objeto</li>
<li>Utilizaci√≥n de programaci√≥n funcional</li>
</ul>
<h2 is-upgraded>Renderizar un elemento</h2>
<p>Para mostrar el contenido de un usuario y que este tenga una sem√°ntica y una estructura que nos ayude a brindarle estilos de una manera m√°s f√°cil, declararemos una funci√≥n llamada <strong>renderElement</strong> la cual recibir√° un usuario y devolver√° una estructura <strong>HTML</strong> de la tarjeta correspondiente a ese usuario.</p>
<pre><code language="language-javascript" class="language-javascript">const renderElement = ({
  id,
  image: src,
  username,
  email,
  gender,
  fullname,
  country,
}) =&gt;
  ` &lt;li class=&#34;card&#34; data-id=&#34;${id}&#34;&gt;
      &lt;div class=&#34;card-main&#34;&gt;
          &lt;figure&gt;
              &lt;img src=&#34;${src}&#34; alt=&#34;Avatar ${username}&#34; loading=&#34;lazy&#34;&gt;
          &lt;/figure&gt;
          &lt;h2 class=&#34;card-main-fullname&#34;&gt;${fullname}&lt;/h2&gt;
          &lt;p class=&#34;card-main-email&#34;&gt;${email}&lt;/p&gt;
          &lt;p class=&#34;card-main-username&#34;&gt;${username}&lt;/p&gt;
          &lt;p class=&#34;card-main-gender&#34;&gt;${gender}&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&#34;card-footer&#34;&gt;
          &lt;h3 class=&#34;card-footer-country&#34;&gt;${country}&lt;/h3&gt;
      &lt;/div&gt;
  &lt;/li&gt; \n`;
</code></pre>
<h2 is-upgraded>Programaci√≥n funcional: reduce</h2>
<p>Al necesitar renderizar n elementos y colocarlos en una misma variable, la programaci√≥n funcional nos brinda el m√©todo <strong>reduce</strong>, el cual, reduce todos los elementos de un arreglo a un solo tipo de dato, en este caso, necesitamos que el tipo de dato sea un <strong>string</strong>. De este modo, declaramos una funci√≥n llamada <strong>renderList</strong> que nos ayudar√° a renderizar los usuarios</p>
<pre><code language="language-javascript" class="language-javascript">const renderList = () =&gt; {
  const usersList = document.querySelector(&#34;#users-list&#34;);
  const usersHTML = users.reduce(
    (list, user) =&gt; list + renderElement(user),
    &#34;&#34;
  );

  usersList.innerHTML = usersHTML;
};
</code></pre>
<aside class="warning"><p> NOTA: No es necesario declarar todos los par√°metros que provee el m√©todo reduce. </p>
</aside>
<p>Ahora que ya tenemos una funci√≥n para renderizar elementos, hacemos uso de ella cuando obtenemos nuestros usuarios, es decir, en la funcion <strong>fetchData</strong>:</p>
<pre><code language="language-javascript" class="language-javascript">const fetchUsers = async () =&gt; {
  users = (await fetchData(&#34;/data/human_1000.json&#34;)) ?? [];
  renderList();
};
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Parte 3 - Listeners" duration="10">
        <h2 is-upgraded>Introducci√≥n</h2>
<p>Los listeners son funciones para eventos que ser√°n invocados cuando realicemos acciones espec√≠ficas dentro de nuestra p√°gina, algunos eventos pueden ser:</p>
<ul>
<li><strong>submit</strong>: Evento que inicia al enviar datos desde un formulario</li>
<li><strong>click</strong>: Evento que inicia cuando se presiona(hace click) a un elemento <strong>HTML</strong></li>
<li><strong>hover</strong>: Evento que inicia cuando se coloca el cursor dentro de un elemento <strong>HTML</strong></li>
</ul>
<h2 is-upgraded>Objetivos</h2>
<ul>
<li>Uso de eventos click.</li>
<li>Uso de <strong>setTimeout</strong> para simular procesos as√≠ncronos.</li>
</ul>
<h2 is-upgraded>Simular una llamada as√≠ncrona</h2>
<p>Simularemos una llamada as√≠ncrona utilizando la funci√≥n <strong>setTimeout</strong>, la cual ejecuta una funci√≥n pasado un tiempo indicado. Entonces, declaramos una funci√≥n <strong>timeout</strong> que recibe un tiempo de resoluci√≥n de una promesa, obteniendo:</p>
<pre><code language="language-javascript" class="language-javascript">const timeout = (time) =&gt; {
  return new Promise((resolve) =&gt; setTimeout(resolve, time));
};
</code></pre>
<aside class="special"><p>  NOTA: Nuestra funci√≥n timeout simula el proceso que tiene que recorrer nuestra petici√≥n desde nuestra computadora a un servidor remoto </p>
</aside>
<p>Con esto funcionando, declaramos la funcion <strong>checkUsers</strong>, que se encarga de actualizar nuestro usuario pasado un tiempo</p>
<pre><code language="language-javascript" class="language-javascript">const checkUsers = () =&gt; {
  const checkPromises = users.map(async (user) =&gt; {
    const seconds = Math.floor(Math.random() * 60);
    await timeout(seconds * 1000);

    const card = document.querySelector(`[data-id=&#34;${user.id}&#34;]`);
    const footer = card.querySelector(&#34;.card-footer&#34;);

    footer.classList.add(&#34;checked&#34;);
  });

  Promise.all(checkPromises);
};
</code></pre>
<p>Procesos a destacar del bloque de c√≥digo mostrado</p>
<p><strong>Paso 1</strong>: Se obtiene un n√∫mero aleatorio entre 0 y 60 con <strong>Math.floor</strong>.</p>
<p><strong>Paso 2</strong>: Se simula mediante <strong>timeout</strong> un espacio de tiempo con el valor calculado anteriormente.</p>
<p><strong>Paso 3</strong>: Como se ha mencionado, al declarar una funci√≥n con <strong>async</strong> logramos que esa funci√≥n retorne una promesa, por consecuente, la variable <strong>checkPromises</strong> ser√° un array de <strong>Promesas</strong> que se deber√° resolver mediante procesos as√≠ncronos </p>
<p><strong>Paso 4</strong>: Como <strong>checkPromises</strong> es un array de promesas, no tenemos el control de realizar un <strong>await</strong> o un <strong>.then</strong> una cantidad finita de veces ya que es necesario resolver cada una de las promesas que este contiene. <strong>Promise</strong> nos brinda un m√©todo especial para este tipo de ocasiones. <strong>Promise.all</strong> recibe un array de promesas que posteriormente, tomar√° cada promesa para resolverla o rechazarla, devolviendo de igual manera un array que contendr√° los resultados.</p>

<aside class="warning"><p>   NOTA: Promise.all resuelve las promesas en el orden que llegan, es decir, el resultado de la primera posici√≥n corresponde a la promesa que estaba en la primera posici√≥n </p>
</aside>
<aside class="special"><p>   NOTA: Promise.all devuelve los resultados √∫nicamente si todos los elementos se resolvieron de manera exitosa, de lo contrario, no devolver√° ningun resultado. ¬øQu√© pasa si algunos campos del array fueran opcionales y fallaran? Leer acerca de Promise.allSetled y su diferencia con Promise.all </p>
</aside>
<h2 is-upgraded>Evento de verificar a los usuarios</h2>
<p>Declaramos una funci√≥n <strong>setupListeners</strong> que se encarga principalmente de manejar los eventos de nuestra aplicaci√≥n. En dicha funci√≥n es necesario declarar el evento click a nuestro bot√≥n de verificar</p>
<pre><code language="language-javascript" class="language-javascript">const setupListeners = () =&gt; {
  const button = document.querySelector(&#34;#check-button&#34;);
  button.addEventListener(&#34;click&#34;, () =&gt; {
    checkUsers()
  });
</code></pre>
<h2 is-upgraded>Iniciar nuestra App</h2>
<p>Para iniciar nuestra app, se propone la siguiente estructura en c√≥digo:</p>
<pre><code language="language-javascript" class="language-javascript">const App = () =&gt; {
  fetchUsers();
  setupListeners();
};

window.onload = App;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Do it yourself" duration="20">
        <h2 is-upgraded>Actividad evaluada del Codelab</h2>
<p>A partir del c√≥digo obtenido como resultado de la realizaci√≥n de este codelab, realizar las siguientes dos funcionalidades, tomando en cuenta:</p>
<ul>
<li>Responsabilidad √∫nica de funciones y atributos.</li>
<li>Reutilizaci√≥n de c√≥digo.</li>
<li>Uso de elementos ES6+ (Destructuraci√≥n, spreading, arrow functions, etc).</li>
<li>Uso de Promesas (con async y await).</li>
</ul>
<h2 is-upgraded>Parte 1: Marcado por pa√≠ses üåé</h2>
<p>A√±adir una entrada de texto al lado del bot√≥n verificar, el cual servir√° para ingresar un pa√≠s cualquiera (Solo el texto). Con el texto obtenido, al dar click en el bot√≥n se deben de rellenar de distinto color los contenedores del pais que coincidan con la entrada de texto. Nota: debe de ser un color distinto al original (crimson), y siempre se deben de marcar los elementos restantes con el estilo original.</p>
<h2 is-upgraded>Parte 2: Eliminado aleatorio ‚ùå</h2>
<p>Imitando la funcionalidad de verificar, se debe a√±adir un bot√≥n de eliminar todos (junto al de verificar), el cual debe de utilizar la l√≥gica de temporizador aleatorio (utilizando en el otro bot√≥n), para ir eliminado las tarjetas del √°rbol DOM.</p>
<h2 is-upgraded>Notas para este ejercicio:</h2>
<ol type="1">
<li>Se debe de reestructurar la funci√≥n checkUsers para realizar cualquier funcionalidad con la l√≥gica de temporizador aleatorio, garantizando la responsabilidad √∫nica y la reutilizaci√≥n de c√≥digo.</li>
<li>No tomar en cuenta el problema de concurrencia en la eliminaci√≥n de elementos de la lista. Primero eliminar gr√°ficamente y luego vaciar el arreglo.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Completaste el codelab" duration="0">
        <p class="image-container"><img alt="finish" src="img\\59763cefe25bfbf7.gif"></p>
<h2 is-upgraded>Has finalizado el laboratorio 02, esperamos te haya sido de mucha ayuda.</h2>
<h2 is-upgraded>¬°Contin√∫a practicando!‚≠ê</h2>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script src="../scripts/main.js"></script>

</body>
</html>
